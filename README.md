## Style-Guid-Java-Script-Naborschikova ##

# 10 правил красивого написания кода Java Script #

### Несколько слов о стиле ##

Код должен быть максимально читаемым и понятным.

Это и есть искусство программирования – взять сложную задачу и написать такой код для её решения, который и правильно работает, и легко читается, понятен для людей. Для этого нужен хороший стиль написания кода. 

«Стиль программирования», или «стандарт кодирования», или «стиль кода» — это набор соглашений, которые используются при написании программ. Они регламентируют особенности оформления кода и порядок использования конструкций, допускающих неоднозначности. В нашем случае речь идёт о программах, написанных на JavaScript. Если программист работает над неким проектом сам, то стиль кода, применяемый им, представляет его «договор» с самим собой. Если речь идёт о команде, то это — соглашения, которые используются всеми членами команды. Код, написанный с применением некоего свода правил, делает кодовую базу программного проекта единообразной, улучшает читабельность и понятность кода.

## Вот некоторые правила, которые помогут написать красивый код ##

### 1. Используйте const для объявления переменных и избегайте var ###
Это гарантирует, что вы не сможете переопределять значения, что могло бы привести к ошибкам и усложнению понимания кода.

Например:

    // плохо
    var a = 1;
    var b = 2;
     
     // хорошо
     const a = 1;
     const b = 2;

### 2. Если вам необходимо переопределять значения, то используйте let вместо var ### 

Область видимости у let - блок, а у var - функция, поэтому это важно.

Например:

    // плохо
    var count = 1;
    if (true) {
        count += 1;
        }

    // хорошо, используйте let.
    let count = 1;
    if (true) {
    count += 1;
    }

* Помните, что у let и const блочная область видимости, в то время как var имеет функциональную область видимости.

Например:

    // const и let существуют только в том блоке, в котором они определены.
    {
    let a = 1;
    const b = 1;
    var c = 1;
    }
    console.log(a); // ReferenceError
    console.log(b); // ReferenceError
    console.log(c); // 1

В приведённом выше коде вы можете видеть, что ссылки на a и b приведут к ошибке ReferenceError, в то время как c содержит число. Это связано с тем, что a и b имеют блочную область видимости, в то время как у c функциональная.

### 3. Деструктуризация ###

При обращении к нескольким свойствам объекта используйте деструктуризацию объекта. Этот метод сохраняет вас от создания временных переменных для этих свойств и от повторного доступа к объекту. Повторный доступ к объектам создаёт более повторяющийся код, требует большего чтения и создаёт больше возможностей для ошибок. Деструктуризация объектов также обеспечивает единое местоположение определения структуры объекта, которое используется в блоке, вместо того, чтобы требовать чтения всего блока для определения того, что используется.

Например:

    // плохо
    function getFullName(user) {
    const firstName = user.firstName;
    const lastName = user.lastName;

    return `${firstName} ${lastName}`;
    }

    // хорошо
    function getFullName(user) {
    const { firstName, lastName } = user;
    return `${firstName} ${lastName}`;
    }

    // отлично
    function getFullName({ firstName, lastName }) {
    return `${firstName} ${lastName}`;
    }

* Используйте деструктуризацию массивов.

Например:

    const arr = [1, 2, 3, 4];

    // плохо
    const first = arr[0];
    const second = arr[1];

    // хорошо
    const [first, second] = arr;

* Используйте деструктуризацию объекта для множества возвращаемых значений, но не делайте тоже самое с массивами. 
Вы сможете добавить новые свойства через некоторое время или изменить порядок без последствий.

    // плохо
    function processInput(input) {
    // затем происходит чудо
    return [left, right, top, bottom];
    }

    // при вызове нужно подумать о порядке возвращаемых данных
    const [left, __, top] = processInput(input);

    // хорошо
    function processInput(input) {
    // затем происходит чудо
    return { left, right, top, bottom };
    }

    // при вызове выбираем только необходимые данные
    const { left, top } = processInput(input);

### 4. Используйте функциональные выражения вместо объявлений функций ### 

У объявлений функций есть подъём. Это означает, что можно использовать функцию до того, как она определена в файле, но это вредит читабельности и поддержке. Если вы обнаружили, что определение функции настолько большое или сложное, что мешает понимать остальную часть файла, то, возможно, пришло время извлечь его в отдельный модуль. Не забудьте явно назвать функциональное выражение, независимо от того, подразумевается ли имя из содержащейся переменной (такое часто бывает в современных браузерах или при использовании компиляторов, таких как Babel). Это помогает точнее определять место ошибки по стеку вызовов.

Например:

    // плохо
    function foo() {
    // ...
    }

    // плохо
    const foo = function () {
    // ...
    };

    // хорошо
    // лексическое имя, отличное от вызываемой(-ых) переменной(-ых)
    const foo = function uniqueMoreDescriptiveLexicalFoo() {
    // ...
    };

### 5. Оборачивайте в скобки немедленно вызываемые функции ###

Немедленно вызываемая функция представляет собой единый блок. Чтобы чётко показать это — оберните функцию и вызывающие скобки в ещё одни скобки. Обратите внимание, что в мире с модулями вам больше не нужны немедленно вызываемые функции.

Например:

    // Немедленно вызываемая функция
    (function () {
    console.log('Welcome to the Internet. Please follow me.');
    }());

### 6. Никогда не называйте параметр arguments ###

Он будет иметь приоритет над объектом arguments, который доступен для каждой функции.

Например: 

    // плохо
    function foo(name, options, arguments) {
    // ...
    }

    // хорошо
    function foo(name, options, args) {
    // ...
    }

А значит, Никогда не используйте arguments, вместо этого используйте синтаксис оставшихся параметров .... Потомучто ... явно говорит о том, какие именно аргументы вы хотите извлечь. Кроме того, такой синтаксис создаёт настоящий массив, а не массивоподобный объект как arguments.

Например:

    // плохо
    function concatenateAll() {
    const args = Array.prototype.slice.call(arguments);
    return args.join('');
    }

    // хорошо
    function concatenateAll(...args) {
    return args.join('');
    }

### 7. Когда вам необходимо использовать анонимную функцию (например, при передаче встроенной функции обратного вызова), используйте стрелочную функцию ###

Таким образом создаётся функция, которая выполняется в контексте this, который мы обычно хотим, а также это более короткий синтаксис.

Почему бы и нет? Если у вас есть довольно сложная функция, вы можете переместить эту логику внутрь её собственного именованного функционального выражения.

Например: 

    // плохо
    [1, 2, 3].map(function (x) {
    const y = x + 1;
    return x * y;
    });

    // хорошо
    [1, 2, 3].map((x) => {
    const y = x + 1;
    return x * y;
    });

И если тело функции состоит из одного оператора, возвращающего выражение без побочных эффектов, то опустите фигурные скобки и используйте неявное возвращение. В противном случае, сохраните фигурные скобки и используйте оператор return. Когда несколько функций соединены вместе, то это лучше читается.

    // плохо
    [1, 2, 3].map((number) => {
    const nextNumber = number + 1;
    `A string containing the ${nextNumber}.`;
    });

    // хорошо
    [1, 2, 3].map((number) => `A string containing the ${number + 1}.`);

    // хорошо
    [1, 2, 3].map((number) => {
    const nextNumber = number + 1;
    return `A string containing the ${nextNumber}.`;
    });

    // хорошо
    [1, 2, 3].map((number, index) => ({
    [index]: number,
    }));

    // Неявный возврат с побочными эффектами
    function foo(callback) {
    const val = callback();
    if (val === true) {
    // Сделать что-то, если функция обратного вызова вернёт true
    }
    }

    let bool = false;

    // плохо
    foo(() => bool = true);

    // хорошо
    foo(() => {
    bool = true;
    });

### 8. Всегда используйте class ###

Избегайте прямых манипуляций с prototype. Синтаксис class является кратким и понятным.

Например: 

    // плохо
    function Queue(contents = []) {
    this.queue = [...contents];
    }
    Queue.prototype.pop = function () {
    const value = this.queue[0];
    this.queue.splice(0, 1);
    return value;
    };

    // хорошо
    class Queue {
    constructor(contents = []) {
    this.queue = [...contents];
    }
    pop() {
    const value = this.queue[0];
    this.queue.splice(0, 1);
    return value;
    }
    }

### 9. Всегда используйте модули (import/export) вместо нестандартных модульных систем ###

Вы всегда сможете транспилировать код в вашу любимую модульную систему. Модули — это будущее. 

Например:

    // плохо
    const AirbnbStyleGuide = require('./AirbnbStyleGuide');
    module.exports = AirbnbStyleGuide.es6;

    // ok
    import AirbnbStyleGuide from './AirbnbStyleGuide';
    export default AirbnbStyleGuide.es6;

    // отлично
    import { es6 } from './AirbnbStyleGuide';
    export default es6;

### 10. Не вызывайте напрямую методы Object.prototype, такие как hasOwnProperty, propertyIsEnumerable, и isPrototypeOf ###

Эти методы могут быть переопределены в свойствах объекта, который мы проверяем { hasOwnProperty: false }, или этот объект может быть null (Object.create(null)).

Например:

    // плохо
    console.log(object.hasOwnProperty(key));

    // хорошо
    console.log(Object.prototype.hasOwnProperty.call(object, key));

    // отлично
    const has = Object.prototype.hasOwnProperty; // Кэшируем запрос в рамках модуля.
    console.log(has.call(object, key));
    /* или */
    import has from 'has'; // https://www.npmjs.com/package/has
    console.log(has(object, key));

## В заключение ##

Существует немало руководств по стилю. Самое главное — последовательно использовать одни и те же правила при работе над неким проектом. При этом, если, например, вы придерживаетесь одного набора правил, а в существующем проекте, над которым вам нужно поработать, используются собственные правила, нужно придерживаться правил проекта. Форматирование кода можно выполнять вручную, а можно воспользоваться средствами автоматизации этого процесса.